- [x] спросить бэкенд про отлетевшие зеркала, недоступные сейчас
- [x] спросить у Пети что делать с аффил айди - вручную вводит пользак
- [x] нужны ли экшны на брендах, что вообще нужно эдитить
- [x] еще раз уточнить альфа 2 или 3, бэковский словарик? - завести на фронте
- [x] получать статусы зеркал - узнать какие нужны и откуда их брать
- [x] откуда брать данные чейндж лога - не будет до MVP
- [x] что значит восклицательный знак на группе и от чего зависит степень окраски
- [x] спросить нужны ли хлебные крошки
- [x] спросить можно ли вернуть бренд из архива или проще создать новый
- [x] узнать в чем отличие инаквив от архива бренда

Задачи:
- [x] интергрировать страницу геотаргетинг 
- [x] интергрировать страницу брендс
- [x] попросить сделать 1 бэйсурл
- [x] добавить после слеша геотаргетинг
- [x] словарь стран
- [ ] попросить сделать ручку для чейнджлог
- [x] нужна серверная пагинация
- [x] модалка создания бренда
- [x] редактирование бренда
- [x] модалка создания группы (активные бренды, словарь стран)
- [x] редактирование группы (drawer)


uuid v7 на пост



```js
import qs from 'qs';

  

import { AUTH_LS_KEY } from '@/shared';

  

import { authStore } from '@/features/authUser';

  

import { pages } from '@/shared/config';

  

const API_BASE_URL = import.meta.env.DEV

? 'https://redirector-private.k8s-dev.rtdlab.cloud/api'

: '/api';

  

type Config<TBody extends object> = {

body?: TBody;

method?: string;

query?: Record<string, unknown>;

skipAuth?: boolean;

};

  

// Храним промис обновления токена

let refreshTokenPromise: Promise<void> | null = null;

  

const defaultQsOptions = { allowDots: true, addQueryPrefix: true };

  

const prepareBackendResponse = async <T>(response?: Response): Promise<T> => {

let data;

  

try {

data = await response?.clone().json();

  

if (response?.ok) {

return data as T;

}

} catch {

data = await response?.text();

}

  

const message = data?.message ?? data?.toString();

  

throw new Error(message ?? 'An error occurred while processing the request');

};

  

const customFetch = async <TBody extends object>(

url: string,

config?: Config<TBody>

) => {

const auth = authStore();

const headers: Record<string, string> = {

'Content-Type': 'application/json',

};

  

if (!config?.skipAuth && auth?.accessToken) {

headers.Authorization = `Bearer ${auth.accessToken}`;

}

  

const preparedUrl = config?.query

? `${url}${qs.stringify(config.query, defaultQsOptions)}`

: url;

  

const fetchOptions: RequestInit = {

method: config?.method || 'GET', // Устанавливаем метод по умолчанию

headers,

};

  

if (config?.body) {

fetchOptions.body = JSON.stringify(config.body);

}

  

console.log('Fetching:', preparedUrl, fetchOptions); // Логирование

  

return fetch(preparedUrl, fetchOptions);

};

  

const performTokenRefresh = async () => {

try {

const refreshToken = authStore()?.refreshToken;

  

if (!refreshToken) {

throw new Error('No refresh token available');

}

  

const refreshResult = await customFetch(`${API_BASE_URL}auth/refresh`, {

skipAuth: true,

method: 'POST',

body: { refreshToken },

});

  

if (refreshResult?.status !== 200) {

authStore.set(null);

localStorage.removeItem(AUTH_LS_KEY);

window.history.pushState(null, '', pages.login.path);

throw new Error('Token refresh failed');

}

  

const data = await refreshResult.json();

  

localStorage.setItem(AUTH_LS_KEY, JSON.stringify(data));

authStore.set(data);

} catch (error) {

refreshTokenPromise = null;

authStore.set(null);

localStorage.removeItem(AUTH_LS_KEY);

window.history.pushState(null, '', pages.login.path);

throw error;

}

};

  

const handleTokenRefresh = async () => {

if (!refreshTokenPromise) {

refreshTokenPromise = performTokenRefresh().finally(() => {

refreshTokenPromise = null;

});

}

  

return refreshTokenPromise;

};

  

const internalFetch = async <T, TBody extends object>(

url: string,

config?: Config<TBody>

): Promise<T> => {

let result = await customFetch(url, config);

  

if (result?.status === 401 && !config?.skipAuth) {

try {

await handleTokenRefresh();

result = await customFetch(url, config);

  

if (result?.status === 401) {

throw new Error('Authentication failed after token refresh');

}

} catch (error) {

console.error('Token refresh failed:', error);

throw error;

}

}

  

return prepareBackendResponse<T>(result);

};

  

export const apiFetch = <T = unknown, TBody extends object = object>(

url: string,

config?: Config<TBody>

): Promise<T> => {

const fullUrl = `${API_BASE_URL}${url}`;

return internalFetch<T, TBody>(fullUrl, config);

};
```

```js
useLogin без трасформации в camesCase

import { useMutation } from '@tanstack/react-query';

import { useNavigate, useSearch } from '@tanstack/react-router';

  

import { AUTH_LS_KEY, errorNotification, gatekeeperFetch } from '@/shared';

  

import { ROOT_PATH } from '@/shared/config';

  

import { authStore } from '../model';

  

export const useLogin = () => {

const navigate = useNavigate();

const search = useSearch({ strict: false });

  

return useMutation({

mutationKey: ['login'],

mutationFn: async (body: {

email: string;

password: string;

}): Promise<{

accessToken: string;

refreshToken: string;

}> =>

gatekeeperFetch('/auth/login', {

body,

method: 'POST',

skipAuth: true,

}),

onSuccess: (data) => {

localStorage.setItem(AUTH_LS_KEY, JSON.stringify(data));

authStore.set(data);

navigate({ to: search.redirect || ROOT_PATH });

},

onError: errorNotification,

});

};
```

```js
useGetBrands без трасформации в camesCase

import { useQuery } from '@tanstack/react-query';

  

import type { BrandsResponse } from '../brands-types';

  

export const useGetBrands = () =>

useQuery({

queryKey: ['getBrands'],

queryFn: async (): Promise<BrandsResponse> => {

const url = new URL('/api/brands', window.location.origin);

const res = await fetch(url.toString());

if (!res.ok) {

throw new Error(`HTTP ${res.status}`);

}

return res.json() as Promise<BrandsResponse>;

},

placeholderData: (previous) => previous,

});
```
```js
<Button

size="large"

color="primary"

variant="solid"

icon={<FolderAddOutlined />}

iconPosition="end"

ghost

onClick={handleAddMirror}>

Add mirror

</Button>


<Button

color="primary"

size="large"

variant="solid"

icon={<DeleteTwoTone />}

ghost

onClick={() => remove(name)}

/>

```

```js
import { Form, Input, Select, Button, Checkbox, Typography, Flex } from 'antd';  
import {  
DeleteOutlined,  
ExclamationCircleFilled,  
FolderAddOutlined,  
HolderOutlined,  
} from '@ant-design/icons';  
import type { FormInstance } from 'antd';  
import { useWatch } from 'antd/es/form/Form';  
import type { DragEndEvent, DraggableAttributes } from '@dnd-kit/core';  
import {  
DndContext,  
PointerSensor,  
useSensor,  
useSensors,  
closestCenter,  
} from '@dnd-kit/core';  
import type { SyntheticListenerMap } from '@dnd-kit/core/dist/hooks/utilities';  
import {  
restrictToVerticalAxis,  
restrictToParentElement,  
} from '@dnd-kit/modifiers';  
import {  
arrayMove,  
SortableContext,  
useSortable,  
verticalListSortingStrategy,  
} from '@dnd-kit/sortable';  
import { CSS } from '@dnd-kit/utilities';  
  
  
import { useGetBrands } from '@/entities/Brands';  
import { useGetCountries } from '@/entities/Countries';  
  
  
import EmptyMirrorsIllustration from './icons/add-morror.svg?react';  
import styles from './GeotargetingForm.module.css';  
  
  
const { Text } = Typography;  
  
  
interface Properties {  
form: FormInstance;  
}  
  
  
interface SortableListItemContextProperties {  
setActivatorNodeRef?: (element: HTMLElement | null) => void;  
listeners?: SyntheticListenerMap;  
attributes?: DraggableAttributes;  
}  
  
  
const SortableListItemContext =  
createContext<SortableListItemContextProperties>({});  
  
  
const DragHandle: React.FC = () => {  
const { setActivatorNodeRef, listeners, attributes } = useContext(  
SortableListItemContext  
);  
return (  
<Button  
type="text"  
size="large"  
icon={<HolderOutlined />}  
style={{ cursor: 'move' }}  
ref={setActivatorNodeRef}  
{...attributes}  
{...listeners}  
/>  
);  
};  
  
  
interface SortableMirrorItemProperties {  
itemKey: string;  
name: number;  
restField: any;  
onRemove: (name: number) => void;  
}  
  
  
const SortableMirrorItem: React.FC<SortableMirrorItemProperties> = ({  
itemKey,  
name,  
restField,  
onRemove,  
}) => {  
const {  
attributes,  
listeners,  
setNodeRef,  
setActivatorNodeRef,  
transform,  
transition,  
isDragging,  
} = useSortable({ id: itemKey });  
  
  
const style: React.CSSProperties = {  
transform: CSS.Translate.toString(transform),  
transition,  
...(isDragging ? { position: 'relative', zIndex: 9999 } : {}),  
};  
  
  
const memoizedValue = useMemo<SortableListItemContextProperties>(  
() => ({ setActivatorNodeRef, listeners, attributes }),  
[setActivatorNodeRef, listeners, attributes]  
);  
  
  
return (  
<SortableListItemContext.Provider value={memoizedValue}>  
<Flex  
ref={setNodeRef}  
style={style}  
gap={12}  
align="start">  
<DragHandle />  
<Form.Item  
{...restField}  
name={[name, 'domain']}  
className={styles.mirrorInput}  
rules={[  
{  
required: true,  
message: 'Please enter domain',  
},  
]}>  
<Input  
placeholder="Enter backup domain URL"  
size="large"  
status="warning"  
suffix={<ExclamationCircleFilled />}  
/>  
</Form.Item>  
<Button  
size="large"  
type="text"  
icon={<DeleteOutlined />}  
onClick={() => onRemove(name)}  
/>  
</Flex>  
</SortableListItemContext.Provider>  
);  
};  
  
  
export const GeotargetingForm = ({ form }: Properties) => {  
const { data: brandsData } = useGetBrands();  
const { data: countriesData } = useGetCountries();  
  
  
const mirrors = useWatch('mirrors', form);  
  
  
const countryOptions =  
countriesData?.countries.map((country) => ({  
value: country.code,  
label: `${country.code} (${country.name})`,  
})) || [];  
  
  
const activeBrands =  
brandsData?.brands.filter((brand) => brand.isActive) || [];  
  
  
const hasMirrors = mirrors && mirrors.length > 0;  
  
  
const sensors = useSensors(  
useSensor(PointerSensor, {  
activationConstraint: {  
distance: 8,  
},  
})  
);  
  
  
const handleAddMirror = () => {  
const currentMirrors = form.getFieldValue('mirrors') || [];  
form.setFieldValue('mirrors', [...currentMirrors, { domain: '' }]);  
};  
  
  
const handleSelectAllCountries = (checked: boolean) => {  
if (checked) {  
const allCountryCodes = countriesData?.countries.map((c) => c.code) || [];  
form.setFieldValue('countryCodes', allCountryCodes);  
} else {  
form.setFieldValue('countryCodes', []);  
}  
};  
  
  
const onDragEnd = ({ active, over }: DragEndEvent) => {  
if (!active || !over || active.id === over.id) {  
return;  
}  
  
  
const currentMirrors = form.getFieldValue('mirrors') || [];  
const activeIndex = currentMirrors.findIndex(  
(_: any, index: number) => `mirror-${index}` === active.id  
);  
const overIndex = currentMirrors.findIndex(  
(_: any, index: number) => `mirror-${index}` === over.id  
);  
  
  
if (activeIndex !== -1 && overIndex !== -1) {  
const newMirrors = arrayMove(currentMirrors, activeIndex, overIndex);  
form.setFieldValue('mirrors', newMirrors);  
}  
};  
  
  
const itemsId = useMemo(  
() =>  
new Array(mirrors?.length || 0)  
.fill(null)  
.map((_, index) => `mirror-${index}`),  
[mirrors?.length]  
);  
  
  
return (  
<Form  
form={form}  
layout="vertical">  
<Flex  
gap={24}  
align="flex-start"  
className={styles.formLayout}>  
<Flex  
gap={16}  
flex={1}  
vertical>  
<Form.Item  
name="name"  
label="Group name"  
rules={[{ required: true, message: 'Please enter group name' }]}>  
<Input  
placeholder="Enter group name"  
size="large"  
/>  
</Form.Item>  
  
  
<Form.Item  
name="brandUid"  
label="Brand"  
rules={[{ required: true, message: 'Please select a brand' }]}>  
<Select  
placeholder="Select a brand"  
optionFilterProp="label"  
size="large"  
showSearch>  
{activeBrands.map((brand) => (  
<Select.Option  
key={brand.uid}  
value={brand.uid}  
label={brand.name}>  
{brand.name}  
</Select.Option>  
))}  
</Select>  
</Form.Item>  
  
  
<Flex  
gap={8}  
vertical>  
<Flex  
justify="space-between"  
align="center">  
<Text>Counties</Text>  
<Form.Item  
name="selectAllCountries"  
valuePropName="checked"  
noStyle>  
<Checkbox  
onChange={(event) =>  
handleSelectAllCountries(event.target.checked)  
}>  
Select all countries  
</Checkbox>  
</Form.Item>  
</Flex>  
<Form.Item  
name="countryCodes"  
rules={[{ required: true, message: 'Please select counties' }]}>  
<Select  
mode="multiple"  
placeholder="Enter or select counties"  
options={countryOptions}  
size="large"  
/>  
</Form.Item>  
</Flex>  
</Flex>  
  
  
<div className={styles.customDivider} />  
  
  
<Flex  
gap={16}  
flex={1}  
vertical>  
<Flex  
gap={36}  
vertical>  
<Flex  
justify="space-between"  
align="center">  
<Text strong>Mirrors ({mirrors?.length || 0})</Text>  
<Button  
size="large"  
color="primary"  
variant="solid"  
icon={<FolderAddOutlined />}  
iconPosition="end"  
onClick={handleAddMirror}>  
Add mirror  
</Button>  
</Flex>  
<Form.Item name="mirrors">  
<Form.List name="mirrors">  
{(fields, { remove }) => (  
<Flex  
align="center"  
justify="center"  
vertical>  
{fields.length > 0 && (  
<DndContext  
sensors={sensors}  
collisionDetection={closestCenter}  
modifiers={[  
restrictToVerticalAxis,  
restrictToParentElement,  
]}  
onDragEnd={onDragEnd}>  
<SortableContext  
items={itemsId}  
strategy={verticalListSortingStrategy}>  
<Flex  
className={styles.mirrorsContainer}  
gap={16}  
vertical>  
{fields.map(  
({ key, name, ...restField }, index) => (  
<SortableMirrorItem  
key={key}  
itemKey={`mirror-${index}`}  
name={name}  
restField={restField}  
onRemove={remove}  
/>  
)  
)}  
</Flex>  
</SortableContext>  
</DndContext>  
)}  
{!hasMirrors && <EmptyMirrorsIllustration />}  
</Flex>  
)}  
</Form.List>  
</Form.Item>  
</Flex>  
</Flex>  
</Flex>  
</Form>  
);  
};  
  
.formLayout {  
margin-top: 40px;  
}  
  
  
.customDivider {  
align-self: stretch;  
width: 1px;  
margin: 0 12px;  
background: rgb(0 0 0 / 10%);  
}  
  
  
.mirrorsContainer {  
width: 100%;  
max-height: 400px;  
padding-right: 4px;  
overflow-y: auto;  
position: relative;  
}  
  
  
.mirrorInput {  
flex: 1;  
}
```